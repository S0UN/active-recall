/**
 * IQuestionRepository - Repository interface for generated questions
 * 
 * Provides persistence operations for questions generated by the LLM question
 * generation service. Follows the established repository pattern and integrates
 * with the spaced repetition system.
 * 
 * Design principles:
 * - Repository pattern for data access abstraction
 * - Domain-driven design with proper error handling
 * - Integration with existing content hash-based identification
 * - Support for question lifecycle management
 * - Optimized queries for spaced repetition scheduling
 */

import { GeneratedQuestion, QuestionType, QuestionDifficulty } from '../contracts/schemas';

/**
 * Question search criteria for flexible querying
 */
export interface QuestionSearchCriteria {
  /** Filter by concept content hash */
  conceptHash?: string;
  
  /** Filter by question types */
  questionTypes?: QuestionType[];
  
  /** Filter by difficulty levels */
  difficulties?: QuestionDifficulty[];
  
  /** Filter by creation date range */
  createdAfter?: Date;
  createdBefore?: Date;
  
  /** Filter by last reviewed date range */
  lastReviewedAfter?: Date;
  lastReviewedBefore?: Date;
  
  /** Filter by concept area/topic */
  conceptArea?: string;
  
  /** Filter by tags */
  tags?: string[];
  
  /** Limit number of results */
  limit?: number;
  
  /** Skip number of results for pagination */
  offset?: number;
}

/**
 * Question storage metadata for tracking
 */
export interface QuestionStorageMetadata {
  /** Total questions stored for concept */
  totalCount: number;
  
  /** Questions by type distribution */
  typeDistribution: Record<QuestionType, number>;
  
  /** Questions by difficulty distribution */
  difficultyDistribution: Record<QuestionDifficulty, number>;
  
  /** First question created date */
  firstCreated: Date;
  
  /** Last question created date */
  lastCreated: Date;
  
  /** Storage size in bytes */
  storageSizeBytes: number;
}

/**
 * Core repository interface for question persistence
 * 
 * Provides CRUD operations and specialized queries for generated questions
 * with proper error handling and performance optimization.
 */
export interface IQuestionRepository {
  /**
   * Save a generated question to persistent storage
   * 
   * @param question - Question to save
   * @returns Promise resolving when save is complete
   * @throws QuestionRepositoryError for storage failures
   * @throws QuestionValidationError for invalid question data
   */
  save(question: GeneratedQuestion): Promise<void>;

  /**
   * Save multiple questions in a batch operation
   * 
   * @param questions - Array of questions to save
   * @returns Promise resolving when all saves are complete
   * @throws QuestionRepositoryError for storage failures
   */
  saveBatch(questions: GeneratedQuestion[]): Promise<void>;

  /**
   * Find a question by its unique identifier
   * 
   * @param questionId - Unique question ID
   * @returns Promise resolving to question or null if not found
   * @throws QuestionRepositoryError for storage access failures
   */
  findById(questionId: string): Promise<GeneratedQuestion | null>;

  /**
   * Find questions by concept content hash
   * 
   * @param conceptHash - Content hash of the source concept
   * @returns Promise resolving to array of questions for the concept
   * @throws QuestionRepositoryError for storage access failures
   */
  findByConceptHash(conceptHash: string): Promise<GeneratedQuestion[]>;

  /**
   * Search questions using flexible criteria
   * 
   * @param criteria - Search criteria and filters
   * @returns Promise resolving to matching questions
   * @throws QuestionRepositoryError for storage access failures
   */
  search(criteria: QuestionSearchCriteria): Promise<GeneratedQuestion[]>;

  /**
   * Get questions ready for review based on spaced repetition schedule
   * 
   * @param conceptHash - Content hash of concept to review
   * @param maxQuestions - Maximum number of questions to return
   * @returns Promise resolving to questions ready for review
   * @throws QuestionRepositoryError for storage access failures
   */
  getQuestionsForReview(conceptHash: string, maxQuestions?: number): Promise<GeneratedQuestion[]>;

  /**
   * Update a question with new data
   * 
   * @param questionId - ID of question to update
   * @param updates - Partial question data to update
   * @returns Promise resolving when update is complete
   * @throws QuestionRepositoryError for storage failures
   * @throws QuestionNotFoundError if question doesn't exist
   */
  update(questionId: string, updates: Partial<GeneratedQuestion>): Promise<void>;

  /**
   * Delete a question by ID
   * 
   * @param questionId - ID of question to delete
   * @returns Promise resolving when deletion is complete
   * @throws QuestionRepositoryError for storage failures
   */
  delete(questionId: string): Promise<void>;

  /**
   * Delete all questions for a concept
   * 
   * @param conceptHash - Content hash of concept
   * @returns Promise resolving to number of questions deleted
   * @throws QuestionRepositoryError for storage failures
   */
  deleteByConceptHash(conceptHash: string): Promise<number>;

  /**
   * Check if questions exist for a concept
   * 
   * @param conceptHash - Content hash of concept
   * @returns Promise resolving to true if questions exist
   * @throws QuestionRepositoryError for storage access failures
   */
  hasQuestionsForConcept(conceptHash: string): Promise<boolean>;

  /**
   * Get metadata about stored questions for a concept
   * 
   * @param conceptHash - Content hash of concept
   * @returns Promise resolving to storage metadata
   * @throws QuestionRepositoryError for storage access failures
   */
  getStorageMetadata(conceptHash: string): Promise<QuestionStorageMetadata>;

  /**
   * Get total count of all stored questions
   * 
   * @returns Promise resolving to total question count
   * @throws QuestionRepositoryError for storage access failures
   */
  getTotalQuestionCount(): Promise<number>;

  /**
   * Clean up old or unused questions
   * 
   * @param olderThanDays - Delete questions older than this many days
   * @returns Promise resolving to number of questions cleaned up
   * @throws QuestionRepositoryError for storage failures
   */
  cleanup(olderThanDays: number): Promise<number>;
}

/**
 * Error classes for question repository operations
 */
export class QuestionRepositoryError extends Error {
  constructor(
    message: string,
    public readonly cause?: Error,
    public readonly context?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'QuestionRepositoryError';
    
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, QuestionRepositoryError);
    }
  }

  static withContext(message: string, context: Record<string, unknown>, cause?: Error): QuestionRepositoryError {
    return new QuestionRepositoryError(message, cause, context);
  }
}

export class QuestionNotFoundError extends QuestionRepositoryError {
  constructor(questionId: string) {
    super(`Question not found: ${questionId}`);
    this.name = 'QuestionNotFoundError';
  }
}

export class QuestionValidationError extends QuestionRepositoryError {
  constructor(
    message: string,
    public readonly validationErrors: string[]
  ) {
    super(`Question validation failed: ${message}. Errors: ${validationErrors.join(', ')}`);
    this.name = 'QuestionValidationError';
  }
}

export class QuestionStorageError extends QuestionRepositoryError {
  constructor(message: string, public readonly operation: string) {
    super(`Question storage error during ${operation}: ${message}`);
    this.name = 'QuestionStorageError';
  }
}